use rly_common::errors::ErrorData;

use super::Token;

mod errors {
	// This module contains the types 'Error' and 'ErrorKind' for errors returned by
	// lexers.

	/// An enum representing the cause of an [`Error`].
	///
	/// [`Error`]'s can have one of two different causes: when the lexer encounters
	/// unrecognisable/unparsable input, and input is recognised by the lexer to be
	/// erronious according to some pre-set condition[^error_rule]. These causes are
	/// represented by [`UnrecognisedInput`](Self::UnrecognisedInput) and
	/// [`ErrorRule`](Self::ErrorRule) respectively.
	///
	/// [^error_rules]: See the documentation for error rules in `lex` for more information on
	/// how this is done in `lex`-generated lexers.

	#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
	pub enum ErrorKind {
		/// Unrecognised input.
		UnrecognisedInput,
		/// Parsable but erronious input.
		ErrorRule,
	}

	/// An error type used by [`Lexer`](super::Lexer)'s.
	///
	/// [`Error`]'s can have one of two different causes: when the lexer encounters
	/// unrecognisable/unparsable input, and input is recognised by the lexer to be
	/// erronious[^error_rules]. In either case, the cause of the error and the offending text
	/// can be inspected with the methods [`kind`](Self::kind) and [`val`](Self::val)
	/// respectively.
	///
	/// [^error_rules]: See the documentation for error rules in `lex` for more information on
	/// how this is caused in `lex`-generated lexers.
	#[derive(Debug)]
	pub struct Error {
		kind: ErrorKind,
		val: String,
	}

	impl Error {
		/// The [kind](ErrorKind) of error; either
		/// [`UnrecognisedInput`](ErrorKind::UnrecognisedInput) for an un-lexable section of
		/// input, or [`ErrorRule`](ErrorKind::ErrorRule) for text that has triggered some
		/// error condition.
		pub fn kind(&self) -> ErrorKind {
			self.kind
		}

		/// The text which caused the error.
		pub fn val(&self) -> &str {
			&self.val
		}

		/// Creates a new instance of [`Error`] with [`ErrorKind::UnrecognisedInput`].
		pub fn unrecognised_input<S: Into<String>>(val: S) -> Self {
			Self {
				kind: ErrorKind::UnrecognisedInput,
				val: val.into(),
			}
		}

		/// Creates a new instance of [`Error`] with [`ErrorKind::ErrorRule`].
		pub fn error_rule<S: Into<String>>(val: S) -> Self {
			Self {
				kind: ErrorKind::ErrorRule,
				val: val.into(),
			}
		}
	}

	impl std::fmt::Display for Error {
		fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
			match self.kind() {
				ErrorKind::UnrecognisedInput => {
					write!(f, "Error: Unrecognized input `{}`", self.val())
				}
				ErrorKind::ErrorRule => {
					write!(f, "Error: Error rule triggered by `{}`", self.val())
				}
			}
		}
	}

	impl std::error::Error for Error {}
}

pub use errors::{Error, ErrorKind};

/// A sister trait to [`Lexer`] representing a type that can take an input [`str`] and
/// return a [`Tokens`].
///
/// Implemented by all references to [`Lexer`]'s. See the [documentation
/// there](Lexer#lexer-intotokens-and-tokens) for more info.
pub trait IntoTokens<'a, T> {
	type Tokens: Tokens<'a, T>;

	fn lex(self, inp: &'a str) -> Self::Tokens;
}

/// A trait representing a [lexer](crate#lexers).
///
/// # `Lexer`, `IntoTokens`, and `Tokens`
///
/// ## `Tokens`
///
/// [`Tokens`] (not to be confused with the struct [`Token`]) is implemented by types
/// returned by lexers (particularly those generated by `lex`) when lexing a source. Types
/// that implement [`Tokens<'s, T>`](Tokens) iterate over the (lazily parsed) tokens of
/// their source, returning a `Result<Token<'s, T>, Error>` (for [`Token`] and [`Error`].)
/// They also provide data on their location within the source for error reporting.
///
/// ## `Lexer` and `IntoTokens`
///
/// For technical reasons surrounding the limitations on associated types in traits, the
/// interface for lexers is split into two traits: [`Lexer`] and [`IntoTokens`].
/// [`IntoTokens`] has a single method [`lex`](IntoTokens::lex), which takes an input
/// string as an argument and consumes `self`, returning a [`Tokens`]. A type which
/// implements [`Lexer`] also implements [`IntoTokens`] on `&'r Self` for any lifetime
/// `'r`. This means that [`lex`](IntoTokens::lex) can be called directly on a [`Lexer`]
/// as a borrowing method.
///
/// ### Example
///
/// ```
/// use std::error::Error;
/// use lex::{IntoTokens, Lexer, Tokens};
///
/// type Result<T> = std::result::Result<T, Box<dyn Error>>;
///
/// enum TokenKind {
/// 	Int,
/// 	Plus,
/// 	Minus,
/// }
/// use TokenKind::*;
///
/// fn calculate<L>(inp: &str) -> Result<i32>
/// where
/// 	L: Lexer<TokenKind>,
/// 	for<'r, 's> &'r L: IntoTokens<'s, TokenKind>,	// required by a bound in Lexer
/// {
/// 	let lexer = L::new();
///
/// 	let mut tokens = lexer.lex(inp);
///
/// 	parse(&mut tokens)
/// }
///
/// fn parse<'s, T: Tokens<'s, TokenKind>>(tokens: &mut T) -> Result<i32> {
/// 	let mut acc: i32 = match tokens.next() {
/// 		Some(res) => res?.val().parse()?,
/// 		None => return Err("empty input".into()),
/// 	};
/// 	loop {
/// 		let op = match tokens.next() {
/// 			Some(res) => res?,
/// 			None => return Ok(acc),
/// 		};
/// 		acc += match op.kind() {
/// 			Plus => expect_int(tokens)?,
/// 			Minus => -expect_int(tokens)?,
/// 			_ => return Err("missing operand".into()),
/// 		};
/// 	};
/// }
///
/// fn expect_int<'s, T: Tokens<'s, TokenKind>>(tokens: &mut T) -> Result<i32> {
/// 	let err_mssg = || -> Box<dyn Error> { "missing integer".into() };
/// 	let tok = tokens.next().ok_or_else(err_mssg)??;
/// 	match tok.kind() {
/// 		Int => Ok(tok.val().parse()?),
/// 		_ => Err(err_mssg()),
/// 	}
/// }
/// ```
pub trait Lexer<T>
where
	for<'r, 's> &'r Self: IntoTokens<'s, T>,
{
	fn new() -> Self;
}

/// An iterator of tokens (lazily) parsed by and underlying [`Lexer`].
///
/// See the [documentation on `Lexer`'s](Lexer#lexer-intotokens-and-tokens) for more
/// information.
pub trait Tokens<'a, T>: Iterator<Item = Result<Token<'a, T>, Error>> {
	fn line(&self) -> &str;

	fn lineno(&self) -> usize;

	fn colno(&self) -> usize;

	fn pos(&self) -> usize;

	fn current_err_data(&self) -> ErrorData {
		ErrorData::new(self.line(), self.lineno(), self.colno(), self.pos())
	}
}
