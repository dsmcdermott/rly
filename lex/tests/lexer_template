compile_error!("This is just a template file and shouldn't be compiled");

use regex::{RegexSet,Regex};

mod rules {
	pub const T_id: &'static str = r"[a-zA-Z_]([0-9a-zA-Z_]*)";
	pub const T_ignore: &'static str = r"[[:space:]]+";
	pub const T_int: &'static str = r"[0-9]+";
	pub const T_error: &'static str = r"/\";
	pub const IGNORE_INDEX: usize = 1;
	pub const ERROR_INDEX: usize = 3;
}

#[derive(Debug,Clone,Copy)]
pub enum TokenKind {
	Tid,
	Tint,
}

const KIND_ARRAY: [Option<TokenKind>; 4] = [Some(TokenKind::Tid),None,Some(TokenKind::Tint),None];

#[derive(Debug,Clone,Copy)]
pub struct Token<'a> {
	kind: TokenKind,
	val: &'a str,
//	line: usize,
//	pos: usize,
}

impl<'a> Token<'a> {
	pub fn kind(&self) -> TokenKind {
		self.kind
	}

	pub fn val(&self) -> &'a str {
		self.val
	}

//	pub fn line(&self) -> usize {
//		self.line
//	}
//
//	pub fn pos(&self) -> usize {
//		self.pos
//	}
}

#[derive(Debug)]
pub struct Error {
	val: String,
}

impl std::fmt::Display for Error {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f,"{}",self.val)
	}
}

impl std::error::Error for Error {}

fn error_from<S: Into<String>>(s: S) -> Error {
	Error { val: s.into() }
}


pub struct LexerRules {
	set: RegexSet,
	regs: [Regex; 4],
}

pub struct Lexer<'r, 's> {
	rules: &'r LexerRules,
	inp: &'s str,
}

impl LexerRules {
	pub fn new() -> Self {
		let set = RegexSet::new([rules::T_id, rules::T_ignore, rules::T_int, rules::T_error]).unwrap();
		let regs = [Regex::new(rules::T_id).unwrap(), Regex::new(rules::T_ignore).unwrap(), Regex::new(rules::T_int).unwrap(), Regex::new(rules::T_error).unwrap()];
		Self { set, regs }
	}

	pub fn lex<'r, 's>(&'r self, inp: &'s str) -> Lexer<'r, 's> {
		Lexer { rules: self, inp }
	}
}

impl<'r, 's> Lexer<'r, 's> {
	fn get_next(&mut self) -> Result<Option<Token<'s>>, Error> {
		if self.inp == "" {
			return Ok(None);
		};
		let match_num = self.rules.set
			.matches(self.inp)
			.iter()
			.next()
			.ok_or_else(|| error_from("Error: Unexpected EOF"))?;
		let reg_match = self.rules.regs[match_num].find(self.inp).unwrap();
		if reg_match.start() != 0 {
			return Err(error_from(
				format!("Error: Unrecognized input `{}`",
					&self.inp[0..reg_match.start()])));
		};
		self.inp = &self.inp[reg_match.end()..];
		let val = reg_match.as_str();
		match match_num {
			rules::IGNORE_INDEX => self.get_next(),
			rules::ERROR_INDEX => Err(error_from(format!("Error: Error rule triggered by `{}`",val))),
			n => Ok(Some(Token { kind: KIND_ARRAY[n].unwrap(), val }))
		}
	}
}

impl<'r, 's> Iterator for Lexer<'r, 's> {
	type Item = Result<Token<'s>, Error>;

	fn next(&mut self) -> Option<Self::Item> {
		self.get_next().transpose()
	}
}
