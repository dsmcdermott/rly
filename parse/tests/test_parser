//compile_error!("This is just a template page and should not be compiled");


#[allow(nonstandard_style, dead_code, unreachable_patterns)]
mod parser {
	//["Fact", "Sum", "Term", "start"]
	//["eof", "id", "int", "lparen", "mult", "plus", "rparen"]

	use parse::lex::{self, Tokens};
	use parse::{
		SyntaxError,
		Error,
		Parser as ParserTrait,
		ast::{self, AstNode, reverse},
	};

	use super::lexer::TokenKind;

	pub type Token<'a> = lex::Token<'a, TokenKind>;

	#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
	pub enum NonTerm {
		N_Fact,
		N_Sum,
		N_Term,
		N_start,
	}

	mod display {
		use std::fmt::{Display, Formatter, Result};
		use super::NonTerm;

		impl Display for NonTerm {
			fn fmt(&self, f: &mut Formatter) -> Result {
				let name = match self {
					NonTerm::N_Fact => "Fact",
					NonTerm::N_Sum => "Sum",
					NonTerm::N_Term => "Term",
					NonTerm::N_start => "start",
				};
				write!(f, "{}", name)
			}
		}
	}

	const START: NonTerm = NonTerm::N_start;

	pub type Ast<'a> = ast::Ast<NonTerm, Token<'a>>;

	type Result<T> = std::result::Result<T, Error>;

	type Res<'a> = Result<(Ast<'a>, usize)>;

	fn ret<'a>(label: NonTerm, children: AstNode<NonTerm, Token<'a>>, n: usize) -> Res<'a> {
		Ok((Ast::new(label, vec![children]), n))
	}

	fn goto_err<'a>() -> Res<'a> {
		panic!("Unexpected error in parsing")
	}

	pub struct Parser<'a, L> {
		inp: L,
		la: Option<Token<'a>>,
	}

	impl<'a, L> Parser<'a, L> {
		fn la(&self) -> &Option<Token<'a>> {
			&self.la
		}

		fn kind(&self) -> Option<TokenKind> {
			match self.la() {
				Some(tok) => Some(*tok.kind()),
				None => None,
			}
		}
	}

	impl<'a, L> Parser<'a, L>
	where
		L: Tokens<'a, TokenKind>,
	{

		fn err_token(&self, tok: &Token<'a>) -> SyntaxError {
			let data = tok.get_error_data();
			SyntaxError::unexpected_token(tok.val(), data)
		}

		fn err_eof(&self) -> SyntaxError {
			let data = self.inp.current_err_data();
			SyntaxError::unexpected_eof(data)
		}

		fn err(&self) -> SyntaxError {
			match self.la() {
				Some(tok) => self.err_token(tok),
				None => self.err_eof(),
			}
		}

		fn shift(&mut self) -> Result<Option<Token<'a>>> {
			let la = self.la;
			self.la = self.inp.next().transpose()?;
			Ok(la)
		}

		fn s0(&mut self) -> Result<Ast<'a>> {
			//0.
			//kernel:
			//	[start -> ·Sum, eof]*
			//closure:
			//	[Term -> ·int, eof]
			//	[Term -> ·int, plus]
			//	[Fact -> ·Term, eof]
			//	[Fact -> ·Fact mult Term, plus]
			//	[Sum -> ·Fact, plus]
			//	[Term -> ·id, eof]
			//	[Term -> ·lparen Sum rparen, plus]
			//	[Term -> ·lparen Sum rparen, eof]
			//	[Sum -> ·Sum plus Fact, eof]
			//	[Term -> ·id, mult]
			//	[Sum -> ·Sum plus Fact, plus]
			//	[Fact -> ·Term, plus]
			//	[Fact -> ·Term, mult]
			//	[Sum -> ·Fact, eof]
			//	[Fact -> ·Fact mult Term, eof]
			//	[Term -> ·int, mult]
			//	[Fact -> ·Fact mult Term, mult]
			//	[Term -> ·lparen Sum rparen, mult]
			//	[Term -> ·id, plus]
			//transitions:
			//	int -> 4
			//	Term -> 5
			//	id -> 6
			//	lparen -> 1
			//	Sum -> 3
			//	Fact -> 2
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_int) => { let la = self.shift()?.unwrap(); self.s4(AstNode::Leaf(la)) }
				Some(TokenKind::T_id) => { let la = self.shift()?.unwrap(); self.s6(AstNode::Leaf(la)) }
				Some(TokenKind::T_lparen) => { let la = self.shift()?.unwrap(); self.s1(AstNode::Leaf(la)) }
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (s, n) = res;
				if n == 0 {
					res = match *s.label() {
						NonTerm::N_Term => self.s5(AstNode::Branch(s)),
						NonTerm::N_Sum => self.s3(AstNode::Branch(s)),
						NonTerm::N_Fact => self.s2(AstNode::Branch(s)),
						NonTerm::N_start => return Ok(s),
						_ => goto_err(),
					}?;
				} else {
					panic!("Unexpected error in parsing")
				};
			};
		}

		fn s1(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//1.
			//kernel:
			//	[Term -> lparen ·Sum rparen, mult]*
			//	[Term -> lparen ·Sum rparen, rparen]*
			//	[Term -> lparen ·Sum rparen, eof]*
			//	[Term -> lparen ·Sum rparen, plus]*
			//closure:
			//	[Sum -> ·Fact, plus]
			//	[Term -> ·int, rparen]
			//	[Term -> ·int, plus]
			//	[Sum -> ·Sum plus Fact, plus]
			//	[Fact -> ·Fact mult Term, mult]
			//	[Term -> ·int, mult]
			//	[Fact -> ·Term, mult]
			//	[Fact -> ·Term, plus]
			//	[Term -> ·lparen Sum rparen, plus]
			//	[Term -> ·lparen Sum rparen, rparen]
			//	[Fact -> ·Term, rparen]
			//	[Term -> ·lparen Sum rparen, mult]
			//	[Sum -> ·Sum plus Fact, rparen]
			//	[Term -> ·id, rparen]
			//	[Term -> ·id, mult]
			//	[Sum -> ·Fact, rparen]
			//	[Fact -> ·Fact mult Term, plus]
			//	[Fact -> ·Fact mult Term, rparen]
			//	[Term -> ·id, plus]
			//transitions:
			//	Term -> 7
			//	Sum -> 11
			//	lparen -> 1
			//	Fact -> 8
			//	int -> 9
			//	id -> 10
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_lparen) => { let la = self.shift()?.unwrap(); self.s1(AstNode::Leaf(la)) }
				Some(TokenKind::T_int) => { let la = self.shift()?.unwrap(); self.s9(AstNode::Leaf(la)) }
				Some(TokenKind::T_id) => { let la = self.shift()?.unwrap(); self.s10(AstNode::Leaf(la)) }
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						NonTerm::N_Term => self.s7(AstNode::Branch(s)),
						NonTerm::N_Sum => self.s11(AstNode::Branch(s)),
						NonTerm::N_Fact => self.s8(AstNode::Branch(s)),
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s2(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//2.
			//kernel:
			//	[Fact -> Fact ·mult Term, plus]*
			//	[Sum -> Fact·, plus]*
			//	[Fact -> Fact ·mult Term, eof]*
			//	[Fact -> Fact ·mult Term, mult]*
			//	[Sum -> Fact·, eof]*
			//closure:
			//transitions:
			//	mult -> 12
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_mult) => { let la = self.shift()?.unwrap(); self.s12(AstNode::Leaf(la)) }
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Sum, val, 0),
				None => return ret(NonTerm::N_Sum, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s3(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//3.
			//kernel:
			//	[Sum -> Sum ·plus Fact, plus]*
			//	[start -> Sum·, eof]*
			//	[Sum -> Sum ·plus Fact, eof]*
			//closure:
			//transitions:
			//	plus -> 13
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_plus) => { let la = self.shift()?.unwrap(); self.s13(AstNode::Leaf(la)) }
				None => return ret(NonTerm::N_start, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s4(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//4.
			//kernel:
			//	[Term -> int·, eof]*
			//	[Term -> int·, plus]*
			//	[Term -> int·, mult]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				None => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s5(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//5.
			//kernel:
			//	[Fact -> Term·, plus]*
			//	[Fact -> Term·, mult]*
			//	[Fact -> Term·, eof]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Fact, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Fact, val, 0),
				None => return ret(NonTerm::N_Fact, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s6(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//6.
			//kernel:
			//	[Term -> id·, mult]*
			//	[Term -> id·, plus]*
			//	[Term -> id·, eof]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				None => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s7(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//7.
			//kernel:
			//	[Fact -> Term·, plus]*
			//	[Fact -> Term·, mult]*
			//	[Fact -> Term·, rparen]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Fact, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Fact, val, 0),
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Fact, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s8(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//8.
			//kernel:
			//	[Fact -> Fact ·mult Term, rparen]*
			//	[Sum -> Fact·, plus]*
			//	[Sum -> Fact·, rparen]*
			//	[Fact -> Fact ·mult Term, mult]*
			//	[Fact -> Fact ·mult Term, plus]*
			//closure:
			//transitions:
			//	mult -> 12
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_mult) => { let la = self.shift()?.unwrap(); self.s12(AstNode::Leaf(la)) }
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Sum, val, 0),
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Sum, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s9(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//9.
			//kernel:
			//	[Term -> int·, rparen]*
			//	[Term -> int·, mult]*
			//	[Term -> int·, plus]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s10(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//10.
			//kernel:
			//	[Term -> id·, rparen]*
			//	[Term -> id·, mult]*
			//	[Term -> id·, plus]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s11(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//11.
			//kernel:
			//	[Term -> lparen Sum ·rparen, eof]*
			//	[Term -> lparen Sum ·rparen, rparen]*
			//	[Sum -> Sum ·plus Fact, rparen]*
			//	[Term -> lparen Sum ·rparen, plus]*
			//	[Term -> lparen Sum ·rparen, mult]*
			//	[Sum -> Sum ·plus Fact, plus]*
			//closure:
			//transitions:
			//	rparen -> 14
			//	plus -> 13
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => { let la = self.shift()?.unwrap(); self.s14(AstNode::Leaf(la)) }
				Some(TokenKind::T_plus) => { let la = self.shift()?.unwrap(); self.s13(AstNode::Leaf(la)) }
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s12(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//12.
			//kernel:
			//	[Fact -> Fact mult ·Term, plus]*
			//	[Fact -> Fact mult ·Term, mult]*
			//	[Fact -> Fact mult ·Term, eof]*
			//	[Fact -> Fact mult ·Term, rparen]*
			//closure:
			//	[Term -> ·id, eof]
			//	[Term -> ·id, plus]
			//	[Term -> ·int, plus]
			//	[Term -> ·lparen Sum rparen, plus]
			//	[Term -> ·lparen Sum rparen, eof]
			//	[Term -> ·int, mult]
			//	[Term -> ·lparen Sum rparen, mult]
			//	[Term -> ·int, rparen]
			//	[Term -> ·int, eof]
			//	[Term -> ·id, mult]
			//	[Term -> ·id, rparen]
			//	[Term -> ·lparen Sum rparen, rparen]
			//transitions:
			//	id -> 17
			//	int -> 16
			//	lparen -> 1
			//	Term -> 15
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_id) => { let la = self.shift()?.unwrap(); self.s17(AstNode::Leaf(la)) }
				Some(TokenKind::T_int) => { let la = self.shift()?.unwrap(); self.s16(AstNode::Leaf(la)) }
				Some(TokenKind::T_lparen) => { let la = self.shift()?.unwrap(); self.s1(AstNode::Leaf(la)) }
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						NonTerm::N_Term => self.s15(AstNode::Branch(s)),
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s13(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//13.
			//kernel:
			//	[Sum -> Sum plus ·Fact, eof]*
			//	[Sum -> Sum plus ·Fact, plus]*
			//	[Sum -> Sum plus ·Fact, rparen]*
			//closure:
			//	[Term -> ·int, plus]
			//	[Fact -> ·Term, mult]
			//	[Term -> ·lparen Sum rparen, plus]
			//	[Fact -> ·Term, rparen]
			//	[Fact -> ·Fact mult Term, rparen]
			//	[Term -> ·id, mult]
			//	[Term -> ·lparen Sum rparen, eof]
			//	[Fact -> ·Term, eof]
			//	[Term -> ·id, eof]
			//	[Fact -> ·Fact mult Term, plus]
			//	[Fact -> ·Term, plus]
			//	[Fact -> ·Fact mult Term, eof]
			//	[Term -> ·int, rparen]
			//	[Term -> ·int, eof]
			//	[Term -> ·int, mult]
			//	[Term -> ·id, rparen]
			//	[Term -> ·id, plus]
			//	[Term -> ·lparen Sum rparen, mult]
			//	[Term -> ·lparen Sum rparen, rparen]
			//	[Fact -> ·Fact mult Term, mult]
			//transitions:
			//	id -> 17
			//	lparen -> 1
			//	Term -> 18
			//	Fact -> 19
			//	int -> 16
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_id) => { let la = self.shift()?.unwrap(); self.s17(AstNode::Leaf(la)) }
				Some(TokenKind::T_lparen) => { let la = self.shift()?.unwrap(); self.s1(AstNode::Leaf(la)) }
				Some(TokenKind::T_int) => { let la = self.shift()?.unwrap(); self.s16(AstNode::Leaf(la)) }
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						NonTerm::N_Term => self.s18(AstNode::Branch(s)),
						NonTerm::N_Fact => self.s19(AstNode::Branch(s)),
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s14(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//14.
			//kernel:
			//	[Term -> lparen Sum rparen·, mult]*
			//	[Term -> lparen Sum rparen·, rparen]*
			//	[Term -> lparen Sum rparen·, plus]*
			//	[Term -> lparen Sum rparen·, eof]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 2),
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Term, val, 2),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 2),
				None => return ret(NonTerm::N_Term, val, 2),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s15(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//15.
			//kernel:
			//	[Fact -> Fact mult Term·, rparen]*
			//	[Fact -> Fact mult Term·, plus]*
			//	[Fact -> Fact mult Term·, eof]*
			//	[Fact -> Fact mult Term·, mult]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Fact, val, 2),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Fact, val, 2),
				None => return ret(NonTerm::N_Fact, val, 2),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Fact, val, 2),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s16(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//16.
			//kernel:
			//	[Term -> int·, rparen]*
			//	[Term -> int·, mult]*
			//	[Term -> int·, plus]*
			//	[Term -> int·, eof]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				None => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s17(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//17.
			//kernel:
			//	[Term -> id·, plus]*
			//	[Term -> id·, eof]*
			//	[Term -> id·, mult]*
			//	[Term -> id·, rparen]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Term, val, 0),
				None => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Term, val, 0),
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Term, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s18(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//18.
			//kernel:
			//	[Fact -> Term·, rparen]*
			//	[Fact -> Term·, plus]*
			//	[Fact -> Term·, mult]*
			//	[Fact -> Term·, eof]*
			//closure:
			//transitions:
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Fact, val, 0),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Fact, val, 0),
				Some(TokenKind::T_mult) => return ret(NonTerm::N_Fact, val, 0),
				None => return ret(NonTerm::N_Fact, val, 0),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}

		fn s19(&mut self, val: AstNode<NonTerm, Token<'a>>) -> Res<'a> {
			//19.
			//kernel:
			//	[Sum -> Sum plus Fact·, eof]*
			//	[Sum -> Sum plus Fact·, plus]*
			//	[Sum -> Sum plus Fact·, rparen]*
			//	[Fact -> Fact ·mult Term, rparen]*
			//	[Fact -> Fact ·mult Term, plus]*
			//	[Fact -> Fact ·mult Term, eof]*
			//	[Fact -> Fact ·mult Term, mult]*
			//closure:
			//transitions:
			//	mult -> 12
			let mut res: (Ast<'a>, usize) = match self.kind() {
				Some(TokenKind::T_mult) => { let la = self.shift()?.unwrap(); self.s12(AstNode::Leaf(la)) }
				None => return ret(NonTerm::N_Sum, val, 2),
				Some(TokenKind::T_plus) => return ret(NonTerm::N_Sum, val, 2),
				Some(TokenKind::T_rparen) => return ret(NonTerm::N_Sum, val, 2),
				_ => Err(Error::from(self.err())),
			}?;
			loop {
				let (mut s, n) = res;
				if n == 0 {
					res = match *s.label() {
						_ => goto_err(),
					}?;
				} else {
					s.push(val);
					return Ok((s, n-1));
				};
			};
		}
	}

	impl<'a, L> Parser<'a, L>
	where
		L: Tokens<'a, TokenKind>,
	{
		pub fn new<I>(inp: I) -> Result<Self>
		where
			I: IntoIterator<IntoIter = L>,
		{
			let mut inp = inp.into_iter();
			let la = inp.next().transpose()?;
			Ok(Self {
				inp,
				la,
			})
		}

		pub fn parse(&mut self) -> Result<Ast<'a>> {
			let mut tree = self.s0()?;
			reverse(&mut tree);
			Ok(tree)
		}
	}

	impl<'a, L> ParserTrait<'a, L, TokenKind, NonTerm, Token<'a>> for Parser<'a, L>
	where
		L: Tokens<'a, TokenKind>,
	{
		fn new<I>(inp: I) -> Result<Self>
		where
			I: IntoIterator<IntoIter = L>,
		{
			Parser::new(inp)
		}

		fn parse(&mut self) -> Result<Ast<'a>> {
			Parser::parse(self)
		}
	}

	pub fn parse<'a, L, I>(iter: I) -> Result<Ast<'a>>
	where
		L: Tokens<'a, TokenKind>,
		I: IntoIterator<IntoIter = L>,
	{
		Parser::new(iter)?.parse()
	}

}
