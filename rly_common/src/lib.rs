//! This is a crate containing code used in both the `lex` and `parse` modules.
//!
//! It contains types like [`ErrorData`](errors::ErrorData) which is used for error
//! formating, and the struct [`BuilderBase`](builders::BuilderBase) which contains the
//! base code used for `LexerBuilder`'s and `ParserBuilder`'s.
//!
//! This crate most likely will not be used directly, instead you'll probably use the
//! re-exports from this crate in `lex` and `parse`.

pub mod builders;

pub mod errors {
	//! A module for generic errors found in text.
	//!
	//! This module contains two structs: [`ErrorData`] and [`LineOffset`]. [`ErrorData`]
	//! contains information usefull for displaying error messages about the location of
	//! an error within a text source, including the [line number](ErrorData::lineno) the
	//! error occured on, the [collumn](ErrorData::colno) it occured on, the
	//! [index](ErrorData::pos) of the error within the source, and the
	//! [line](ErrorData::line) on which it occured.
	//!
	//! An [`ErrorData`] can be generated from the source text and an index or position
	//! within that text using [`ErrorData::find`], like so:
	//!
	//! ```
	//! # use rly_common::errors::ErrorData;
	//! let text = "\
	//! abc def
	//! ghi jkl
	//! mnop";
	//!
	//! let err_data = ErrorData::find(text, 12).unwrap();
	//!
	//! assert_eq!(err_data.line(), "ghi jkl");
	//! assert_eq!(err_data.lineno(), 1);
	//! assert_eq!(err_data.colno(), 4);
	//! assert_eq!(err_data.pos(), 12);
	//! ```
	//!
	//! [`LineOffset`] is essentially just a wrapper for [`ErrorData`] that implements
	//! [`Display`](std::fmt::Display) by printing the [`line`](ErrorData::line) on which
	//! the error occured along with a caret `^` inserted underneath the beginning of the
	//! error, like so:
	//!
	//! ```
	//! # use rly_common::errors::ErrorData;
	//! let text = "\
	//! abc def
	//! ghi jkl
	//! mnop";
	//!
	//! let err_data = ErrorData::find(text, 12).unwrap();
	//!
	//! assert_eq!(&err_data.line_offset().to_string(), "\
	//! ghi jkl
	//!     ^  ");
	//! ```

	use std::{convert::AsRef, fmt};

	/// A type containing information about the location of an error in text.
	///
	/// [`ErrorData`] contains information usefull for displaying error messages about the
	/// location of an error within a text source, including the [line
	/// number](ErrorData::lineno) the error occured on, the [collumn](ErrorData::colno)
	/// it occured on, the [index](ErrorData::pos) of the error within the source, and the
	/// [line](ErrorData::line) on which it occured.
	///
	/// An [`ErrorData`] can be generated from the source text and an index or position
	/// within that text using [`ErrorData::find`], like so:
	///
	/// ```
	/// # use rly_common::errors::ErrorData;
	/// let text = "\
	/// abc def
	/// ghi jkl
	/// mnop";
	///
	/// let err_data = ErrorData::find(text, 12).unwrap();
	///
	/// assert_eq!(err_data.line(), "ghi jkl");
	/// assert_eq!(err_data.lineno(), 1);
	/// assert_eq!(err_data.colno(), 4);
	/// assert_eq!(err_data.pos(), 12);
	/// ```
	///
	/// [`ErrorData::new`] can also be used to directly make new [`ErrorData`] instances,
	/// however it does not check to verify that the provided data is correct.
	#[derive(Debug, PartialEq, Eq, Clone)]
	pub struct ErrorData {
		line: String,
		lineno: usize,
		colno: usize,
		pos: usize,
	}

	/// A struct that [`Display`s](fmt::Display) its [`line`][LineOffset::line] with a
	/// caret `^` underneath the collumn [`colno`][LineOffset::colno].
	///
	/// Can be generated by [`ErrorData`]'s for error message formatting. For example:
	///
	/// ```
	/// # use rly_common::errors::ErrorData;
	/// let text = "\
	/// 1 2 3
	/// 4 a 6
	/// 7 8 9";
	///
	/// let (index, char) = text
	/// 	.char_indices()
	/// 	.filter(|(i, c)| !c.is_whitespace())
	/// 	.find(|(i, c)| !c.is_numeric())
	/// 	.unwrap();
	///
	/// let err_message = format!(
	/// 	"the character '{}' is not a numeric character:\n{}",
	/// 	char,
	/// 	ErrorData::find(text, index)
	/// 		.unwrap()
	/// 		.line_offset()
	/// );
	///
	/// assert_eq!(&err_message, "\
	/// the character 'a' is not a numeric character:
	/// 4 a 6
	///   ^  ");
	/// ```
	#[derive(Debug)]
	pub struct LineOffset<S: AsRef<str>> {
		pub line: S,
		pub colno: usize,
	}

	impl<S: AsRef<str>> fmt::Display for LineOffset<S> {
		/// Prints `self.line`[LineOffset::line] with a caret `^` undernath the column
		/// [`self.colno`][LineOffset::colno].
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::LineOffset;
		/// let line_offset = LineOffset { line: "foo bar baz", colno: 4 };
		///
		/// assert_eq!(&format!("{}", line_offset), "\
		/// foo bar baz
		///     ^      ");
		/// ```
		fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
			let s = self.line.as_ref();
			let offset = self.colno + 1;
			let remainder = s.len().checked_sub(offset).unwrap_or(0);
			write!(
				f,
				"{}\n{:>offset$}{:remainder$}",
				s,
				"^",
				"",
				offset = offset,
				remainder = remainder
			)
		}
	}

	impl ErrorData {
		/// The contents of the line on which the error occured.
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.line(), "ghi jkl");
		/// ```
		pub fn line(&self) -> &str {
			&self.line
		}

		/// The line number where the error occured.
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.lineno(), 1);
		/// ```
		pub fn lineno(&self) -> usize {
			self.lineno
		}

		/// The column number where the error occured.
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.colno(), 4);
		/// ```
		pub fn colno(&self) -> usize {
			self.colno
		}

		/// The position of the error within its source text, as the byte index for the
		/// start of the error within the UTF-8 source.
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.pos(), 12);
		/// ```
		pub fn pos(&self) -> usize {
			self.pos
		}

		/// Generates an [`ErrorData`] from a source string `text` and the index `pos` of
		/// the error. Returns [`None`] if `pos` is greater than or equal to
		/// [`text.len()`](str::len).
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.line(), "ghi jkl");
		/// assert_eq!(err_data.lineno(), 1);
		/// assert_eq!(err_data.colno(), 4);
		/// assert_eq!(err_data.pos(), 12);
		/// ```
		pub fn find(text: &str, pos: usize) -> Option<Self> {
			let (line, lineno, colno) = Self::gen_data(text, pos)?;
			Some(Self::new(line, lineno, colno, pos))
		}

		/// Returns the line, line number, and column number associated with the index
		/// `pos` within the source `text`. Returns [`None`] if `pos` is greater than or
		/// equal to [`text.len()`](str::len).
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let (line, lineno, colno) = ErrorData::gen_data(text, 12).unwrap();
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(line, err_data.line());
		/// assert_eq!(lineno, err_data.lineno());
		/// assert_eq!(colno, err_data.colno());
		/// ```
		pub fn gen_data(text: &str, pos: usize) -> Option<(&str, usize, usize)> {
			if pos >= text.len() {
				return None;
			};
			let mut line_offset = 0;
			for (lineno, line) in text.split('\n').enumerate() {
				let end = line_offset + line.len() + 1;
				if end >= pos {
					return Some((line, lineno, pos - line_offset));
				};
				line_offset = end;
			}
			unreachable!();
		}

		/// Creates a new [`ErrorData`] with the provided data.
		///
		/// # Example
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let err_data = ErrorData::new("ghi jkl", 1, 4, 12);
		///
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let found_err = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data, found_err);
		/// ```
		/// Note however that it does not check to varify that the provided data is
		/// accurate. For example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let err_data = ErrorData::new("ghi jkl", 1, 6, 12);
		///
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let found_err = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(err_data.line(), found_err.line());
		/// assert_eq!(err_data.lineno(), found_err.lineno());
		/// assert_eq!(err_data.pos(), found_err.pos());
		/// assert_ne!(err_data.colno(), found_err.colno());	// The column number for 'err_data` is incorrect.
		/// ```
		pub fn new<S: Into<String>>(line: S, lineno: usize, colno: usize, pos: usize) -> Self {
			Self {
				line: line.into(),
				lineno,
				colno,
				pos,
			}
		}

		/// Generates a [`LineOffset`] for `self`.
		///
		/// # Example
		///
		/// ```
		/// # use rly_common::errors::ErrorData;
		/// let text = "\
		/// abc def
		/// ghi jkl
		/// mnop";
		///
		/// let err_data = ErrorData::find(text, 12).unwrap();
		///
		/// assert_eq!(&err_data.line_offset().to_string(), "\
		/// ghi jkl
		///     ^  ");
		/// ```
		pub fn line_offset(&self) -> LineOffset<&str> {
			LineOffset {
				line: &self.line,
				colno: self.colno,
			}
		}
	}

	#[cfg(test)]
	mod tests {
		#[test]
		fn test_line_offset() {
			use super::LineOffset;
			let line = "foo bar baz";
			let outp = &r"
foo bar baz
     ^     "[1..];
			let line_offset = LineOffset {
				line: line,
				colno: 5,
			};
			assert_eq!(&format!("{}", line_offset), outp);
		}

		#[test]
		fn test_find() {
			use super::ErrorData;
			let text = r"
foo bar baz
biz buz";
			let err = ErrorData::find(text, 6);
			println!("{:?}", err);
			println!("{}$", err.unwrap().line_offset());
		}
	}
}
